<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><base href="../"><link rel="stylesheet" href="dmdoc.css"><title>monkestation/README_old.md - MonkeStation 2.0</title></head><body><header><a href="index.html">MonkeStation 2.0</a> - <a href="index.html#modules">Modules</a> - <a href="index.html#types">Types</a></header><main><h1>The Modular Folder <aside>monkestation/README_old.md</aside> <a href="https://github.com/wraith-54321/Monkestation2.0/blob/e87cd5865da73e1fc78dbf3ac640d3e7369d7fa2/monkestation/README_old.md"><img src="git.png" width="16" height="16" title="monkestation/README_old.md"></a></h1><table class="summary" cellspacing="0"><tr><td colspan="2"><h2 id="introduction">Introduction</h2>
<p>Monkestation is a downstream fork of <a href="https://github.com/tgstation/tgstation">tgstation</a>, meaning that our code is originally based off of them. In addition, from time-to-time, will pull PRs into our codebase from theirs. The difficulty of pulling upstream PRs is made significantly easier with <strong>modularization</strong>.</p>
<h2 id="important-note-test-your-pull-requests">Important note - TEST YOUR PULL REQUESTS</h2>
<p>You are responsible for the testing of your content. You should not mark a pull request ready for review until you have actually tested it. If you require a separate client for testing, you can use a guest account by logging out of BYOND and connecting to your test server. Test merges are not for bug finding, they are for stress tests where local testing simply doesn't allow for this.</p>
<h3 id="the-nature-of-conflicts">The nature of conflicts</h3>
<p>For example, let's have an original</p>
<pre><code class="language-byond">var/something = 1
</code></pre>
<p>in the core code, that we decide to change from 1 to 2 on our end,</p>
<pre><code class="language-diff">- var/something = 1
+ var/something = 2 //MONKESTATION EDIT
</code></pre>
<p>but then our upstream introduces a change in their codebase, changing it from 1 to 4</p>
<pre><code class="language-diff">- var/something = 1
+ var/something = 4
</code></pre>
<p>As easy of an example as it is, it results in a relatively simple conflict, in the form of</p>
<pre><code class="language-byond">var/something = 2 //MONKESTATION EDIT
</code></pre>
<p>where we pick the preferable option manually.</p>
<h3 id="the-solution">The Solution</h3>
<p>That is something that cannot and likely shouldn't be resolved automatically, because it might introduce errors and bugs that will be very hard to track down, not to even bring up more complex examples of conflicts, such as ones that involve changes that add, remove and move lines of code all over the place.</p>
<p>tl;dr it tries its best but ultimately is just a dumb program, therefore, we must ourselves do work to ensure that it can do most of the work, while minimizing the effort spent on manual involvement, in the cases where the conflicts will be inevitable.</p>
<p>Our answer to this is modularization of the code.</p>
<p><strong>Modularization</strong> means, that most of the changes and additions we do, will be kept in a separate <strong><code>monkestation/</code></strong> folder, as independent from the core code as possible, and those which absolutely cannot be modularized, will need to be properly marked by comments. More details will be found in the next section.</p>
<h2 id="the-modularization-protocol">The Modularization Protocol</h2>
<p>Always start by thinking of the theme/purpose of your work. It's oftentimes a good idea to see if there isn't an already existing one, that you should append to.</p>
<p><strong>If it's a tgcode-specific tweak or bugfix, first course of action should be an attempt to discuss and PR it upstream, and then cherry-pick pulling the PR down here.</strong></p>
<p>The <code>/monkestation</code> folder will look fairly similar to tgstation's, following the same file structure. Thus, if you are modularizing something, attempt to mirror the tgcode file structure in the <code>/monkestation</code> folder as best as possible.</p>
<h3 id="maps">Maps</h3>
<p>Tgcode map edits can, unfortunately, not be modularized. As such, it is heavily recommended to attempt PRing it to tgstation first if it is a simple fix or QOL change.</p>
<h3 id="assets-images-sounds-icons-and-binaries">Assets: images, sounds, icons and binaries</h3>
<p>Git doesn't handle conflicts of binary files well at all, therefore changes to core binary files are absolutely forbidden, unless you have a really <em>really</em> <strong><em>really</em></strong> good reason to do otherwise.</p>
<p>All assets added should be placed in the <code>/monkestation</code> folder.</p>
<ul>
<li>
<p><strong><em>Example:</em></strong> You're adding a new lavaland mob.</p>
<p>First of all, you want to find a regular lavaland mob's file path, which would be <code>code/modules/mob/living/simple_animal/hostile/mining_mobs/</code>.</p>
<p>Next, you want to mirror that in the <code>/monkestation</code> folder, making it <code>/monkestation/code/modules/mob/living/simple_animal/hostile/mining_mobs/your_new_mob_here.dm</code></p>
<p>Then, you add the new mob to that new file in the <code>/monkestation</code> folder, like so.</p>
<pre><code class="language-byond">  /mob/lavaland/newmob
    icon = 'monkestation/icons/mob.dmi'
    icon_state = &quot;dead_1&quot;
    sound = 'monkestation/sounds/boom.ogg'
</code></pre>
<p>This ensures your code is fully modular and will make it easier for future edits.</p>
</li>
<li>
<p>Other assets, binaries and tools, should usually be handled likewise, depending on the case-by-case context. When in doubt, ask a maintainer or other contributors for tips and suggestions.</p>
</li>
</ul>
<h2 id="modular-overrides-important">Modular Overrides (Important!!)</h2>
<p>Note, that it is possible to append code in front, or behind a core proc, in a modular fashion, without editing the original proc, through referring the parent proc, using <code>..()</code>, in one of the following forms. And likewise, it is possible to add a new var to an existing datum or obj, without editing the core files.</p>
<p>To keep it simple, let's assume you wanted to make guns spark when shot, for simulating muzzle flash or whatever other reasons, and you want potentially to use it with all kinds of guns.</p>
<p>You could start, in a modular file, by adding a var.</p>
<pre><code class="language-byond">/obj/item/gun
    var/muzzle_flash = TRUE
</code></pre>
<p>And it will work just fine. Afterwards, let's say you want to check that var and spawn your sparks after firing a shot.
Knowing the original proc being called by shooting is</p>
<pre><code class="language-byond">/obj/item/gun/proc/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
</code></pre>
<p>You can define a child proc for it, that will get inserted into the inheritance chain of the related procs (big words, but in simple cases like this, you don't need to worry)</p>
<pre><code class="language-byond">/obj/item/gun/shoot_live_shot(mob/living/user, pointblank = 0, atom/pbtarget = null, message = 1)
    . = ..() //. is the default return value, we assign what the parent proc returns to it, as we call it before ours
    if(muzzle_flash)
        spawn_sparks(src) //For simplicity, I assume you've already made a proc for this
</code></pre>
<p>And that wraps the basics of it up.</p>
<h3 id="non-modular-changes-to-the-core-code-important">Non-modular Changes to the Core Code - IMPORTANT</h3>
<p>Every once in a while, there comes a time, where editing the core files becomes inevitable.</p>
<p>In those cases, this is the following convention, with examples:</p>
<ul>
<li>
<p><strong>Addition:</strong></p>
<pre><code class="language-byond">//MONKESTATION EDIT START
var/adminEmergencyNoRecall = FALSE
var/lastMode = SHUTTLE_IDLE
var/lastCallTime = 6000
//MONKESTATION EDIT END
</code></pre>
</li>
<li>
<p><strong>Removal:</strong></p>
<pre><code class="language-byond">//MONKESTATION REMOVAL START
/*
for(var/obj/docking_port/stationary/S in stationary)
  if(S.id = id)
    return S
*/
//MONKESTATION REMOVAL END
WARNING(&quot;couldn't find dock with id: [id]&quot;)
</code></pre>
</li>
<li>
<p><strong>Change:</strong></p>
<pre><code class="language-byond">//MONKESTATION EDIT START
//if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE) - MONKESTATION EDIT ORIGINAL
if(SHUTTLE_STRANDED, SHUTTLE_ESCAPE, SHUTTLE_DISABLED)
//MONKESTATION EDIT END
    return 1
</code></pre>
</li>
</ul>
<h2 id="afterword">Afterword</h2>
<p>It might seem like a lot to take in, but if we remain consistent, it will save a lot of maintainer headache in the long run, once we start having to resolve conflicts manually.
Thanks to a bit more scrupulous documentation, it will be immediately obvious what changes were done and where and by which features, and things will be a lot less ambiguous and messy.</p>
<p>Best of luck in your coding. Remember that the community is there for you, if you ever need help.</p></td></tr></table></main><footer>tgstation.dme <a href="https://github.com/wraith-54321/Monkestation2.0/tree/e87cd5865da73e1fc78dbf3ac640d3e7369d7fa2">e87cd58</a> (master) â€” <a href="https://github.com/SpaceManiac/SpacemanDMM/blob/master/crates/dmdoc/README.md">dmdoc 1.11.0</a></footer></body></html>